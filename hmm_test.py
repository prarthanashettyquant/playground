# -*- coding: utf-8 -*-
"""HMM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tuwqki7JQ7gEiu8mxkpAWFsMpGbQJVdm
"""

!pip install yfinance hmmlearn scikit-learn --quiet
import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import StandardScaler
from hmmlearn.hmm import GaussianHMM
from sklearn.metrics import adjusted_rand_score
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.ensemble import RandomForestClassifier
from scipy.stats import mode
from xgboost import XGBClassifier

class RegimeAnalyzer:
    def __init__(self, tickers, start_date="2006-01-01"):
        self.tickers = tickers
        self.start_date = start_date
        self.scaler = StandardScaler()
        self.model = None
        self.data = None
        self.train_data = None
        self.test_data = None
        self.train_features = None
        self.test_features = None
        self.regime_label_map = {}

    def load_data(self):
        self.data = yf.download(self.tickers, start=self.start_date)['Close'].dropna()

    def engineer_features(self, smooth_window=5):
        df = self.data.copy()
        df['SPX_return_1M'] = df['^GSPC'].pct_change(21)
        df['RV_10D'] = df['^GSPC'].pct_change().rolling(10).std() * np.sqrt(252)
        df['VIX_slope'] = df['^VIX3M'] - df['^VIX']
        df['^VVIX'] = df['^VVIX'].rolling(smooth_window).mean()

        # Apply smoothing
        df['SPX_return_1M'] = df['SPX_return_1M'].rolling(smooth_window).mean()
        #df['RV_10D'] = df['RV_10D'].rolling(smooth_window).mean()
        #df['VIX_slope'] = df['VIX_slope'].rolling(smooth_window).mean()

        df.dropna(inplace=True)
        self.data = df

        # ðŸ’¾ Store features used by classifier and HMM
        self.features = self.scaler.fit_transform(df[['SPX_return_1M', 'RV_10D', 'VIX_slope', '^VVIX']])



    def split_train_test_predict(self, test_start="2018-01-01", predict_start="2023-01-01"):
        """
        Split into 3 segments: train, test (for evaluation), predict (forward inference).
        """
        df = self.data.copy()
        self.train_data = df[df.index < test_start].copy()
        self.test_data = df[(df.index >= test_start) & (df.index < predict_start)].copy()
        self.predict_data = df[df.index >= predict_start].copy()

        # Align features
        mask_train = df.index < test_start
        mask_test = (df.index >= test_start) & (df.index < predict_start)
        mask_predict = df.index >= predict_start

        self.train_features = self.features[mask_train]
        self.test_features = self.features[mask_test]
        self.predict_features = self.features[mask_predict]


    def fit_and_project_oos(self, n_states, seed=42):
        """
        Fit HMM on train, predict on test and predict segments, and relabel consistently.
        """
        hmm = GaussianHMM(n_components=n_states, covariance_type='full', n_iter=1000, random_state=seed)
        hmm.fit(self.train_features)

        self.model = hmm
        self.train_data['Regime'] = hmm.predict(self.train_features)
        self.test_data['Regime'] = hmm.predict(self.test_features)
        self.predict_data['Regime'] = hmm.predict(self.predict_features)

        self._relabel_using_train_only(method='vol')

        # Combine for downstream use
        self.data = pd.concat([self.train_data, self.test_data, self.predict_data]).sort_index()


    def _relabel_using_train_only(self, method="vol"):
        """
        Relabel regimes based on train set only for consistency.
        """
        if method == "vol":
            regime_order = self.train_data.groupby('Regime')['RV_10D'].mean().sort_values(ascending=False).index.tolist()
        elif method == "drawdown":
            self.train_data['FwdDrawdown_10D'] = self.train_data['^GSPC'] / self.train_data['^GSPC'].rolling(10).max().shift(-10) - 1
            regime_order = self.train_data.groupby('Regime')['FwdDrawdown_10D'].mean().sort_values().index.tolist()
        elif method == "return":
            self.train_data['SPX_return_20D'] = self.train_data['^GSPC'].pct_change(20).shift(-20)
            regime_order = self.train_data.groupby('Regime')['SPX_return_20D'].mean().sort_values().index.tolist()
        else:
            raise ValueError("Choose 'vol', 'drawdown', or 'return'")

        relabel_map = {old: new for new, old in enumerate(regime_order)}
        self.regime_label_map = {0: 'Stress', 1: 'High Pre-Stress', 2: 'Low Pre-Stress', 3: 'Calm'}

        for df in [self.train_data, self.test_data, self.predict_data]:
            df['Regime'] = df['Regime'].map(relabel_map)
            df['RegimeLabel'] = df['Regime'].map(self.regime_label_map)


    def test_hmm_stability(self, n_runs=10, baseline_seed=42, plot=True):
        baseline_model = GaussianHMM(n_components=3, covariance_type='full', n_iter=1000, random_state=baseline_seed)
        baseline_model.fit(self.train_features)
        baseline_states = baseline_model.predict(self.train_features)

        scores = []
        for seed in range(n_runs):
            model = GaussianHMM(n_components=3, covariance_type='full', n_iter=1000, random_state=seed)
            model.fit(self.train_features)
            test_states = model.predict(self.train_features)
            score = adjusted_rand_score(baseline_states, test_states)
            scores.append((seed, score))

        df = pd.DataFrame(scores, columns=["Seed", "RandIndex"]).sort_values("RandIndex", ascending=False)

        if plot:
            plt.figure(figsize=(10, 4))
            plt.bar(df["Seed"], df["RandIndex"], color='steelblue')
            plt.axhline(0.9, color='red', linestyle='--', label="High stability threshold")
            plt.title("Adjusted Rand Index Across Seeds vs Baseline")
            plt.xlabel("Seed")
            plt.ylabel("Rand Index")
            plt.grid(True)
            plt.legend()
            plt.show()

        return df

    def auto_select_best_seed(self, n_runs=20, baseline_seed=42):
        df = self.test_hmm_stability(n_runs=n_runs, baseline_seed=baseline_seed, plot=False)
        best_seed = int(df.iloc[0]['Seed'])
        print(f"âœ… Best seed selected: {best_seed} (Rand Index = {df.iloc[0]['RandIndex']:.3f})")
        return best_seed

    def evaluate_regime_drawdowns(self, horizon=10):
        df = self.test_data.copy()
        df['FwdDrawdown'] = df['^GSPC'].rolling(window=horizon).max().shift(-horizon)
        df['FwdDrawdown'] = df['^GSPC'] / df['FwdDrawdown'] - 1

        regime_groups = df.groupby('RegimeLabel')['FwdDrawdown'].agg(['mean', 'std', 'count'])
        regime_groups.rename(columns={'mean': f'AvgDrawdown_{horizon}D', 'std': 'StdDev', 'count': 'Samples'}, inplace=True)

        print(f"\nðŸ“‰ Forward {horizon}-day drawdown by regime (out-of-sample):\n")
        return regime_groups

    def plot_regimes(self):
        color_map = {'Calm': 'green', 'Low Pre-Stress': 'yellow', 'High Pre-Stress': 'blue', 'Stress': 'red'}
        fig, ax = plt.subplots(figsize=(15, 6))
        for regime, label in self.regime_label_map.items():
            mask = self.data['Regime'] == regime
            ax.plot(self.data.index[mask], self.data['^GSPC'][mask], '.', label=label, color=color_map[label], alpha=0.6)
        ax.set_title("SPX with Regime Overlay")
        ax.legend()
        plt.show()

    def plot_transition_matrix(self):
        trans_mat = self.model.transmat_
        labels = [self.regime_label_map[i] for i in range(trans_mat.shape[0])]

        plt.figure(figsize=(6, 4))
        im = plt.imshow(trans_mat, cmap='Blues', interpolation='nearest')
        plt.colorbar(im, label="Transition Probability")
        plt.xticks(range(len(labels)), labels)
        plt.yticks(range(len(labels)), labels)
        plt.title("HMM Regime Transition Matrix")
        plt.xlabel("To Regime")
        plt.ylabel("From Regime")

        for i in range(len(labels)):
            for j in range(len(labels)):
                prob = trans_mat[i, j]
                plt.text(j, i, f"{prob:.2f}", ha="center", va="center", color="black")

        plt.tight_layout()
        plt.show()

    def plot_feature_distributions(self):
        features_to_plot = ['SPX_return_1M', 'RV_10D', 'VIX_slope', '^VVIX']
        for feature in features_to_plot:
            plt.figure(figsize=(8, 4))
            sns.boxplot(data=self.data, x='RegimeLabel', y=feature)
            plt.title(f'{feature} distribution by Regime')
            plt.grid(True)
            plt.show()

    def plot_forward_cumulative_returns(self, horizon=20):
        df = self.data.copy()
        df['FwdReturn'] = df['^GSPC'].pct_change(horizon).shift(-horizon)

        plt.figure(figsize=(12, 6))

        for label in df['RegimeLabel'].unique():
            mask = df['RegimeLabel'] == label
            sub = df.loc[mask, ['FwdReturn']].copy()
            sub = sub.dropna()

            # Reset index for consistent plotting
            sub['Cumulative'] = (1 + sub['FwdReturn']).cumprod()
            plt.plot(sub.index, sub['Cumulative'], label=label)

        plt.title(f'Cumulative Forward SPX Returns by Regime ({horizon}D Horizon)')
        plt.yscale('log')  # or comment this out for linear scale
        plt.grid(True)
        plt.legend()
        plt.show()

    def smooth_regime_predictions(self, series, window=5):
        """
        Applies a rolling mode filter to a regime prediction series.

        Args:
            series (pd.Series): Series of predicted regime labels.
            window (int): Rolling window size. Must be odd.

        Returns:
            pd.Series: Smoothed series.
        """
        if window % 2 == 0:
            raise ValueError("Window size must be odd for centered mode smoothing.")

        smoothed = series.copy()

        for i in range(window//2, len(series) - window//2):
            window_slice = series.iloc[i - window//2 : i + window//2 + 1]
            smoothed.iloc[i] = int(mode(window_slice, keepdims=False).mode)

        return smoothed

    def train_supervised_classifier(self, model_type="logistic", confidence_threshold=0.6):
        """
        Trains a supervised classifier to predict HMM regimes from features.
        Supports 'logistic' and 'random_forest'. Applies to test and predict segments.
        Uses confidence thresholding to flag uncertain predictions.
        """
        X_train = self.train_features
        y_train = self.train_data['Regime'].values
        X_test = self.test_features
        y_test = self.test_data['Regime'].values
        X_predict = self.predict_features

        # Initialize model
        if model_type == "logistic":
            clf = LogisticRegression(max_iter=1000, multi_class='multinomial')
        elif model_type == "random_forest":
            clf = RandomForestClassifier(n_estimators=100, max_depth=5)
        elif model_type == "xgboost":
          clf = XGBClassifier(n_estimators=100, max_depth=5, learning_rate=0.1, use_label_encoder=False, eval_metric='mlogloss')
        else:
            raise ValueError("Invalid model type: choose 'logistic' or 'random_forest'.")

        # Train model
        clf.fit(X_train, y_train)

        # --- Test predictions ---
        probs_test = clf.predict_proba(X_test)
        preds_test = np.argmax(probs_test, axis=1)
        max_probs_test = np.max(probs_test, axis=1)
        self.test_data['RegimePredicted'] = preds_test
        self.test_data['RegimePredicted'] = self.smooth_regime_predictions(self.test_data['RegimePredicted'], window=5)
        self.test_data['PredictionConfidence'] = max_probs_test
        self.test_data['LowConfidence'] = max_probs_test < confidence_threshold

        # --- Future predictions ---
        probs_predict = clf.predict_proba(X_predict)
        preds_predict = np.argmax(probs_predict, axis=1)
        max_probs_predict = np.max(probs_predict, axis=1)
        self.predict_data['RegimePredicted'] = preds_predict
        self.predict_data['RegimePredicted'] = self.smooth_regime_predictions(self.predict_data['RegimePredicted'], window=5)
        self.predict_data['PredictionConfidence'] = max_probs_predict
        self.predict_data['LowConfidence'] = max_probs_predict < confidence_threshold

        # --- Evaluation ---
        print("ðŸ“Š Classification Report (Test):")
        print(classification_report(y_test, preds_test, target_names=[self.regime_label_map[i] for i in sorted(self.regime_label_map)]))

        print("\nðŸ” Confusion Matrix:")
        cm = confusion_matrix(y_test, preds_test)
        sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
                    xticklabels=[self.regime_label_map[i] for i in sorted(self.regime_label_map)],
                    yticklabels=[self.regime_label_map[i] for i in sorted(self.regime_label_map)])
        plt.xlabel("Predicted")
        plt.ylabel("True")
        plt.title("Regime Classifier Confusion Matrix (Test Data)")
        plt.show()

        # Optionally store model
        self.classifier_model = clf



    def plot_classifier_predictions(self, horizon=20):
        """
        Plot actual vs predicted regimes on test data,
        and cumulative forward SPX returns grouped by predicted regimes
        (for both test and predict segments).
        """
        import matplotlib.dates as mdates

        # --- Plot 1: Actual vs Predicted Regimes (Test Set) ---
        fig, ax = plt.subplots(2, 1, figsize=(14, 8), sharex=True)

        test_df = self.test_data.copy()
        predict_df = self.predict_data.copy()

        ax[0].set_title("ðŸ“˜ Test Data: Actual vs Predicted Regimes")
        ax[0].plot(test_df.index, test_df['Regime'], label="Actual", color="black", lw=1)
        ax[0].plot(test_df.index, test_df['RegimePredicted'], label="Predicted", color="orange", linestyle='--', lw=1)
        ax[0].legend(loc="upper left")
        ax[0].set_ylabel("Regime Index")
        ax[0].xaxis.set_major_formatter(mdates.DateFormatter('%Y'))

        # --- Plot 2: Cumulative Fwd Return by Predicted Regimes ---
        for df, segment in zip([test_df, predict_df], ['Test', 'Predict']):
            df['FwdReturn'] = df['^GSPC'].pct_change(horizon).shift(-horizon)
            df = df.dropna(subset=['FwdReturn', 'RegimePredicted'])

            plt.figure(figsize=(12, 5))
            for regime_id in sorted(df['RegimePredicted'].unique()):
                label = self.regime_label_map.get(regime_id, f"Regime {regime_id}")
                mask = df['RegimePredicted'] == regime_id
                sub = df.loc[mask].copy()
                sub['Cumulative'] = (1 + sub['FwdReturn']).cumprod()
                plt.plot(sub.index, sub['Cumulative'], label=label)

            plt.title(f"ðŸ“ˆ Cumulative Forward SPX Returns by Predicted Regime ({segment} Segment, {horizon}D Horizon)")
            plt.ylabel("Cumulative Return")
            plt.grid(True)
            plt.legend()
            plt.yscale('log')
            plt.tight_layout()
            plt.show()


    def plot_low_confidence_regions(self, segment='test', highlight_threshold=0.6):
        """
        Visualize regions where the classifier was uncertain (low confidence predictions).
        `segment` must be one of: 'test' or 'predict'.
        """
        assert segment in ['test', 'predict'], "Choose 'test' or 'predict'"
        df = self.test_data if segment == 'test' else self.predict_data

        if 'PredictionConfidence' not in df.columns:
            raise ValueError("Run `train_supervised_classifier()` first to generate prediction confidences.")

        low_conf_mask = df['PredictionConfidence'] < highlight_threshold

        fig, ax = plt.subplots(figsize=(15, 4))
        ax.plot(df.index, df['RegimePredicted'], label="Predicted Regime", color='black', lw=1)

        # Overlay low-confidence regions
        ax.scatter(df.index[low_conf_mask], df['RegimePredicted'][low_conf_mask],
                  color='red', marker='x', label='Low Confidence (< {:.2f})'.format(highlight_threshold))

        ax.set_title(f"Low Confidence Regime Predictions â€” {segment.capitalize()} Data")
        ax.set_ylabel("Predicted Regime")
        ax.legend()
        ax.grid(True)
        plt.show()

    def simulate_regime_short_strategy(self, data='predict', short_return_col='SPX_return_1D'):
        """
        Strategy: go short SPX when predicted regime is 'Stress', flat otherwise.
        Computes and plots cumulative strategy return vs buy-and-hold SPX.

        Parameters:
            data (str): One of 'test' or 'predict' to determine which segment to run on.
            short_return_col (str): Column name for daily SPX returns. If not present, it will be computed.

        Returns:
            DataFrame with daily strategy return, SPX return, signal, and cumulative returns.
        """
        df = getattr(self, f"{data}_data").copy()

        if short_return_col not in df.columns:
            df[short_return_col] = df['^GSPC'].pct_change()

        stress_code = [k for k, v in self.regime_label_map.items() if v == 'Stress'][0]
        df['Signal'] = (df['RegimePredicted'] == stress_code).astype(int)
        df['StrategyReturn'] = -1 * df[short_return_col] * df['Signal']
        df['StrategyCumulative'] = (1 + df['StrategyReturn']).cumprod()
        df['SPX_Cumulative'] = (1 + df[short_return_col]).cumprod()

        plt.figure(figsize=(12, 6))
        plt.plot(df.index, df['StrategyCumulative'], label='Short SPX on Stress Regime')
        #plt.plot(df.index, df['SPX_Cumulative'], label='Buy-and-Hold SPX', linestyle='--')
        plt.title("Regime-Based SPX Short Strategy vs Buy-and-Hold")
        plt.xlabel("Date")
        plt.ylabel("Cumulative Return")
        plt.grid(True)
        plt.legend()
        plt.tight_layout()
        plt.show()

        return df[['StrategyReturn', short_return_col, 'Signal', 'StrategyCumulative', 'SPX_Cumulative']]

    def simulate_regime_short_strategy_on_full_oos(self, short_return_col='SPX_return_1D'):
        """
        Strategy: short SPX during 'Stress' and 'High Pre-Stress' predicted regimes,
        long with small weight during 'Calm', flat otherwise.
        Runs on concatenated test + predict data.
        """
        df = pd.concat([self.test_data, self.predict_data]).sort_index().copy()

        if short_return_col not in df.columns:
            df[short_return_col] = df['^GSPC'].pct_change()

        # Map predicted regime codes
        short_regimes = [k for k, v in self.regime_label_map.items() if v in ['Stress', 'High Pre-Stress']]
        long_regimes = [k for k, v in self.regime_label_map.items() if v == 'Calm']

        # Generate signals
        df['SignalShort'] = df['RegimePredicted'].isin(short_regimes).astype(int)
        df['SignalLong'] = df['RegimePredicted'].isin(long_regimes).astype(int)

        # Combine returns
        df['StrategyReturn'] = (
            -1.0 * df[short_return_col] * df['SignalShort'] +
            0.25 * df[short_return_col] * df['SignalLong']
        )

        # Cumulative returns
        df['StrategyCumulative'] = (1 + df['StrategyReturn']).cumprod()
        df['SPX_Cumulative'] = (1 + df[short_return_col]).cumprod()

        # Plot
        plt.figure(figsize=(12, 6))
        plt.plot(df.index, df['StrategyCumulative'], label='ðŸ“‰ Short on Stress / Pre-Stress + Light Long on Calm')
        plt.plot(df.index, df['SPX_Cumulative'], label='ðŸ“ˆ Buy-and-Hold SPX', linestyle='--')
        plt.title("ðŸ“Š Regime-Based Tactical SPX Strategy")
        plt.xlabel("Date")
        plt.ylabel("Cumulative Return")
        plt.grid(True)
        plt.legend()
        plt.tight_layout()
        plt.show()

        return df[['StrategyReturn', short_return_col, 'SignalShort', 'SignalLong', 'StrategyCumulative', 'SPX_Cumulative']]

    def simulate_smart_spx_shorting(self, df, regime_ids_to_short=[0, 1], confidence_threshold=0.4, vol_percentile=70, lookback=5):
        """
        Simulates a refined SPX shorting strategy:
        - Only short when predicted regime is in [High Pre-Stress, Stress]
        - Confidence of classifier is high
        - Volatility is elevated
        - Market has rallied in the past week

        Returns the dataframe with signal, daily strategy return, and cumulative performance.
        """
        df = pd.concat([self.test_data, self.predict_data]).copy()

        df["SPX_return_1W"] = df["^GSPC"].pct_change(lookback)
        vol_cutoff = np.percentile(df["RV_10D"].dropna(), vol_percentile)

        df["Signal"] = 0
        mask = (
            df["RegimePredicted"].isin(regime_ids_to_short) &
            (df["PredictionConfidence"] >= confidence_threshold) &
            (df["RV_10D"] >= vol_cutoff) &
            (df["SPX_return_1W"] > 0)
        )
        df.loc[mask, "Signal"] = -1  # short signal

        df["SPX_return_1D"] = df["^GSPC"].pct_change()
        df["StrategyReturn"] = df["Signal"].shift(1) * df["SPX_return_1D"]

        df["Cumulative_SPX"] = (1 + df["SPX_return_1D"]).cumprod()
        df["Cumulative_Strategy"] = (1 + df["StrategyReturn"]).cumprod()

        # Plotting performance
        plt.figure(figsize=(12, 6))
        #plt.plot(df.index, df["Cumulative_SPX"], label="SPX Buy & Hold", color="black")
        plt.plot(df.index, df["Cumulative_Strategy"], label="Refined Short Strategy", color="red")
        plt.legend()
        plt.title("SPX vs Refined Short Strategy (Cumulative Returns)")
        plt.grid(True)
        plt.yscale("log")
        plt.show()

        return df

analyzer = RegimeAnalyzer(tickers=['^GSPC', '^VIX', '^VIX3M', '^VVIX'])
analyzer.load_data()
analyzer.engineer_features()
analyzer.split_train_test_predict(test_start="2018-01-01", predict_start="2023-01-01")

n_states = 4
best_seed = analyzer.auto_select_best_seed(n_runs=20, baseline_seed=42)
analyzer.fit_and_project_oos(n_states, seed=best_seed)

analyzer.plot_regimes()
analyzer.plot_transition_matrix()
analyzer.plot_feature_distributions()

analyzer.evaluate_regime_drawdowns(horizon=10)

analyzer.plot_forward_cumulative_returns(horizon=20)

analyzer.train_supervised_classifier(model_type="xgboost")
analyzer.plot_low_confidence_regions(segment='test', highlight_threshold=0.6)
analyzer.plot_classifier_predictions(horizon=20)

#analyzer.train_supervised_classifier(model_type="logistic")

#analyzer.train_supervised_classifier(model_type="random_forest")
#result_df = analyzer.simulate_regime_short_strategy(data='test')

result_df = analyzer.simulate_regime_short_strategy_on_full_oos()
result_df